[
  {
    "id": "p2gmej667mh1sy4c5",
    "title": "初识C++",
    "category": "C++",
    "tags": [
      "笔记，概念，基础"
    ],
    "content": "# C++\n\n于 1982 年左右诞生于美国贝尔实验室，一门既支持面向对象编程，也支持面向过程编程的高级编程语言。\n\nC++ 是一门新的编程语言，它直接继承了 C 语言的一切语法特性，在此基础上增加了一些新的语法特性：面向对象编程(OOP)、bool 数据类型、引用类型、模板、异常处理、命名空间、RTTI 等。\n\n面向过程编程：将项目问题拆解为若干个实现步骤，每个步骤用一个或多个函数实现，然后将这些函数按照合理的顺序依次调用就能解决项目问题。\n\n面向对象编程(OOP, Object Oriented Program)：将软件系统中的各个功能模块使用对象表示，对象与对象之间相互通信（交互）就能够实现各种功能。\n\n对象(Object)：一个实际存在的事物。\n\n类(Class)：具有相同特征的对象集合，它是对象的抽象，不是具体存在的事物。\n\n类是对象的抽象，而对象是类的实例(Instance)。\n\n> C 语言是面向过程的高级编程语言\n\n> Cursor：功能强大的 AI 编程工具。\n\n如何快速学好 C++++：C 语言学会了，C++就会了 85%，如果已学过 C 语言，只需要稍加学习一下 C++ 新增的语法特性就可以掌握 C++ ++。\n\nC++ 源文件的后缀名为 .cpp 或 .cc。\n\ng++：GNU 组织推出的 C++ 编译器，开源免费。\n\n\\\nC++ 标准库头文件不使用任何后缀名，比如 iostream、cstring、cstdio 等。\n\n**C++ 新增数据类型**\n\nbool：布尔数据类型，占 1 字节存储空间。\n\nstring：字符串类型。\n\n引用(Reference)是一种特殊数据类型，它相当于被引用数据的别名，不会分配新的内存空间。引用其实就是封装了指针，它比指针更容易使用，容错性也更高，在大部分场合可以替代指针。\n\n引用必须先声明后使用，一旦声明后，引用关系就不能改变。\n\n```\nint a = 3;\nint b = a;   // 定义一个 int 类型的变量 b，其初始值和变量 a 一样\nint& c = a;  // 定义(或声明)一个 int 类型引用 c，它是变量 a 的引用，其实就是变量 a 的别名\n\nb++;\ncout << a << endl;  // 3\n\nc++;\ncout << a << endl;  // 4\n\na++;\ncout << c << endl;  // 5\n\n```\n\n常引用：在定义引用时左侧加上 const 关键字修饰，表示该引用的目标是只读的（在该引用眼中），不能通过该引用对它的目标进行写操作，否则编译报错。\n\n在调用函数时，C 语言只支持传值，而 C++ 支持传值和传引用两种方式。\n\nC++ 编程建议：多使用引用，少用指针！如果函数的形参是比较大的数据（比如结构体、对象、数组等），强烈建议要用引用，效率更高；如果在函数内部不需要对引用的目标进行写操作，强烈建议使用常引用！\n\n在 C++ 中使用结构体类型、共用体类型、枚举类型时，可以不写 struct、union、enum 关键字。\n\nC++ 将标准 C 库中的头文件（比如 stdio.h、string.h、stdlib.h、time.h、math.h 等）都 copy 了一份，并换了一个新的文件名(没有后缀名 .h，加一个前缀 c），比如 cstdio、cstring、cstdlib、ctime，cmath 等。\n\n**夯实基础：**\n\n浮点数(float 和 double)在内存中是按照 IEEE754 标准规定的格式存储的，具体规则是：最高位表示符号位，0 表示正，1 表示负；接下来的若干位就是指数部分，float 类型的指数部分是 8 位，double 类型的指数部分是 11 位；剩下的位是尾数部分，float 类型的尾数部分是 23 位，double 类型的尾数部分是 52 位。\n\nfloat f = -3.125;\n\n整数部分（除 2 取余，逆序写出）：3 --> 11\n\n小数部分（乘 2 取整，正序写出，直到小数部分为零）：0.125 --> 0.25 --> 0.5 -> 1.0\n\n001\n\n十进制小数 3.125 转换为二进制小数为 11.001\n\n转换为科学计数法形式：1.1001 \\* 2^1\n\n指数部分：1 + 127 --> 128 --> 1000 0000\n\n变量 f 的存储形态：1 1000 0000 1001 0000 0000 0000 0000 000\n\nfloat f = 3.9;\n\n1.111100 1100 1100 1100 1101 0 \\* 2^1\n\n0100 0000 0111 1001 1001 1001 1001 1010 --> 40 79 99 9A\n\n1.0 \\* 2^0\n\n0011 1111 1000 0000 0000 0000 0000 0000\n\n0100 0000 0111 1001 1001 1001 1001 1010",
    "date": "2025-10-22"
  },
  {
    "id": "pa20u9okamh1pp9kd",
    "title": "STM32 GPIO 入门与常见坑",
    "category": "STM32",
    "tags": [
      "STM32",
      "GPIO",
      "HAL"
    ],
    "date": "2025-10-12",
    "content": "# STM32 GPIO 入门与常见坑\n\n**目标**：快速把 GPIO 配置起来并避免常见问题。\n\n## 关键点\n- 时钟：先使能 `__HAL_RCC_GPIOx_CLK_ENABLE()`\n- 模式：推挽/开漏 + 上拉/下拉\n- 速度：不要一上来就 Very High\n- 复用：查 `AFx` 映射表\n\n```c\nGPIO_InitTypeDef GPIO_Init = {0};\n__HAL_RCC_GPIOA_CLK_ENABLE();\nGPIO_Init.Pin = GPIO_PIN_5;\nGPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;\nGPIO_Init.Pull = GPIO_NOPULL;\nGPIO_Init.Speed = GPIO_SPEED_FREQ_LOW;\nHAL_GPIO_Init(GPIOA, &GPIO_Init);\n```\n\n> 小贴士：外设复用时一定要同时配置 `AF` 和 `Mode`。"
  },
  {
    "id": "pochyxpr1mh1pp9kd",
    "title": "C 指针速查：从地址到数组",
    "category": "C",
    "tags": [
      "C",
      "指针",
      "内存"
    ],
    "date": "2025-09-15",
    "content": "# C 指针速查\n\n- `&` 取地址，`*` 解引用  \n- 数组名在表达式中会衰减为指向首元素的指针  \n- `const` 位置不同，语义不同：`const int *p` vs `int * const p`\n\n```c\nint a = 10;\nint *p = &a;  // p 保存 a 的地址\nprintf(\"%d\\n\", *p); // 解引用得到 10\n```\n\n[CPPReference：指针](https://en.cppreference.com/w/c/language/pointer)"
  },
  {
    "id": "poxq1arz9mh1pp9kd",
    "title": "C++ 智能指针一页纸",
    "category": "C++",
    "tags": [
      "C++",
      "智能指针",
      "RAII"
    ],
    "date": "2025-08-28",
    "content": "# C++ 智能指针\n\n- `unique_ptr`：独占所有权，禁止拷贝，可移动  \n- `shared_ptr`：共享所有权，引用计数  \n- `weak_ptr`：观察者，不影响计数，解决环引用  \n\n```cpp\nauto p = std::make_unique<int>(42);\n```\n\n> 经验：优先使用 `unique_ptr`，必要时再考虑 `shared_ptr`。"
  }
]