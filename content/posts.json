[
  {
    "id": "pmltbk0khmh3dmdnv",
    "title": "小白也能学会的在服务器上配置code-server教程(解决阿里云与GitHub代码仓互通问题)",
    "category": "ssh",
    "tags": [
      "教程",
      "云服务器",
      "GitHub"
    ],
    "content": "# 以阿里云服务器为例\n\n由于在本小比长达二十分钟的努力下，还是无法让阿里云服务器和GitHub完成通信，所以采用了一个先下载文件再传输到服务器的办法。好在本地文件到阿里云服务器的传输并不难，用xshell打开服务器之后用xftp完成文件传输即可。（没有xftp的可以搜一下这个不难）\n\n## 那么我们正式开始，首先我们打开下面的链接下载我们的code-server安装包到本地上\n\n**官方 GitHub 下载地址**：\\\n👉 [https://github.com/coder/code-server/releases](https://github.com/coder/code-server/releases?utm_source=chatgpt.com)\n\n🔹 或者直接下载最新版（截至现在是 `v4.105.1`）：\\\n👉 <https://github.com/coder/code-server/releases/download/v4.105.1/code-server-4.105.1-linux-amd64.tar.gz>\n\n下载完成后我们会得到一个这样的文件\n\n```bash\ncode-server-4.105.1-linux-amd64.tar.gz\n```\n\n然后我们把这个文件上传到咱们服务器的root@你的服务器IP:/usr/local/这个文件夹下。\n\n然后我们就可以直接登录到我们的服务器，依次执行下面的命令\n\n```bash\ncd /usr/local\ntar -xzf code-server-4.105.1-linux-amd64.tar.gz\nmv code-server-4.105.1-linux-amd64 code-server\nln -sf /usr/local/code-server/bin/code-server /usr/local/bin/code-server\n```\n\n执行完之后我们下面来创建配置文件\n\n```bath\nmkdir -p /root/.config/code-server\nnano /root/.config/code-server/config.yaml\n```\n\ntips:其实我更喜欢用vim，但是没有vim的按照这个执行就行。\n\n然后在里面写入以下内容\n\n```yaml\nbind-addr: 0.0.0.0:(你开通的端口号，如8080)\nauth: password\npassword: (你的不能被别人知道的密码)\ncert: false\n```\n\n保存退出。\n\n那么好我们现在可以启动我买的code-server了，直接启动\n\n```bath\ncode-server\n```\n\n启动后会显示类似这样的消息\n\n```nginx\ninfo  code-server 4.105.1 425d1a...\ninfo  HTTP server listening on http://0.0.0.0:8080\ninfo    - Authentication is enabled\ninfo    - Using password from ~/.config/code-server/config.yaml\n```\n\n这样就启动成功了，现在你可以在浏览器访问了！！！\n\n```cpp\nhttp://你的服务器公网IP:8080(这个冒号后面的是你的端口号)\n```\n\n密码就是上面那个。\n\n## 如果希望自动随系统启动，那么输入下面这段代码。\n\n```bath\ncat > /etc/systemd/system/code-server.service <<EOF\n[Unit]\nDescription=Code Server IDE\nAfter=network.target\n\n[Service]\nType=simple\nUser=root\nExecStart=/usr/local/bin/code-server --config /root/.config/code-server/config.yaml\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\nsystemctl daemon-reload\nsystemctl enable --now code-server\n```\n\n### 那么此时就有聪明的同学就要问了老比为什么我打不开这个网页啊\n\n那你问到点了，可能是你的端口没放开\n\n登录你的 **阿里云控制台 → 云服务器 ECS → 安全组 → 入方向规则**\\\n确保放行以下端口：\n\n| 端口   | 协议  | 说明          |\n| :--- | :-- | :---------- |\n| 9009 | TCP | code-server |\n| 80   | TCP | Nginx HTTP  |\n| 443  | TCP | HTTPS       |\n\n那么大家按照以上内容运行完之后应该能打开了，下面教大家配置一个Nginx反向代理以确保大家能管理自己的页面和端口不冲突，不然8080端口被占用了就老实了。\n\n打开你的 Nginx 配置文件（或创建新的站点配置）：\n\n```\nnano /etc/nginx/sites-available/code-server.conf\n\n```\n\n写入以下内容（完整复制）👇\n\n```\nserver {\n    listen 80;\n    server_name bibi.ink;\n\n    location / {\n        proxy_pass http://127.0.0.1:9009/;\n        proxy_set_header Host $host;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection upgrade;\n        proxy_set_header Accept-Encoding gzip;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n```\n\n保存退出后执行：\n\n```\nln -s /etc/nginx/sites-available/code-server.conf /etc/nginx/sites-enabled/\nnginx -t\nsystemctl reload nginx\n\n```\n\n如果你在浏览器访问 `http://你的ip地址或域名` 能出现 `code-server 登录界面`，就说明反代成功。\n\n***\n\n## 配置 HTTPS（SSL）\n\n现在加上 Let’s Encrypt 免费证书：\n\n### 1️⃣ 安装 certbot\n\n```\napt install certbot python3-certbot-nginx -y\n\n```\n\n### 2️⃣ 一键申请证书并自动配置\n\n```\ncertbot --nginx -d 你的域名或ip\n\n```\n\n按照提示输入邮箱，然后选择自动重定向 HTTPS。\n\n执行完后，再次访问：\n\n```\nhttps://你的域名或ip\n\n```\n\n应该能直接打开你的 VS Code 登录页面 ✅\n\n这个时候有人就要说了啊，我不爱看英文我爱看中文.那么按照下面操作可以修改配置为默认中文，vscode里面大家自己下载中文包就好。\n\n## 手动指定语言为中文\n\n如果你想强制 code-server 启动时默认中文，可以修改配置：\n\n```\nnano /root/.config/code-server/config.yaml\n\n```\n\n在文件最后添加一行：\n\n```\nlocale: zh-cn\n\n```\n\n保存退出，再重启：\n\n```\nsystemctl restart code-server\n\n```\n\n***\n\n这样，无论你是手动重启还是自动启动，都会默认加载简体中文语言包。\n\n\n\n那么好现在大家都安装成功了。\n\n经小比测试咱们在云服务器上部署的这个code-sever服务不仅能实时与咱们的云服务器上的文件同步,还能登录咱们的GitHub管理咱们的代码仓,这下大家不管在哪掏出手机平板只要登录上咱们的网页也能学习或者加班写代码看代码了,方便的很.\n\n(如果你喜欢我的教程请给我点一个赞,这对我真的很重要.)",
    "date": "2025-10-23"
  },
  {
    "id": "p2gmej667mh1sy4c5",
    "title": "初识C++",
    "category": "C++",
    "tags": [
      "笔记，概念，基础"
    ],
    "content": "# C++\n\n于 1982 年左右诞生于美国贝尔实验室，一门既支持面向对象编程，也支持面向过程编程的高级编程语言。\n\nC++ 是一门新的编程语言，它直接继承了 C 语言的一切语法特性，在此基础上增加了一些新的语法特性：面向对象编程(OOP)、bool 数据类型、引用类型、模板、异常处理、命名空间、RTTI 等。\n\n面向过程编程：将项目问题拆解为若干个实现步骤，每个步骤用一个或多个函数实现，然后将这些函数按照合理的顺序依次调用就能解决项目问题。\n\n面向对象编程(OOP, Object Oriented Program)：将软件系统中的各个功能模块使用对象表示，对象与对象之间相互通信（交互）就能够实现各种功能。\n\n对象(Object)：一个实际存在的事物。\n\n类(Class)：具有相同特征的对象集合，它是对象的抽象，不是具体存在的事物。\n\n类是对象的抽象，而对象是类的实例(Instance)。\n\n> C 语言是面向过程的高级编程语言\n\n> Cursor：功能强大的 AI 编程工具。\n\n如何快速学好 C++++：C 语言学会了，C++就会了 85%，如果已学过 C 语言，只需要稍加学习一下 C++ 新增的语法特性就可以掌握 C++ ++。\n\nC++ 源文件的后缀名为 .cpp 或 .cc。\n\ng++：GNU 组织推出的 C++ 编译器，开源免费。\n\n\\\nC++ 标准库头文件不使用任何后缀名，比如 iostream、cstring、cstdio 等。\n\n**C++ 新增数据类型**\n\nbool：布尔数据类型，占 1 字节存储空间。\n\nstring：字符串类型。\n\n引用(Reference)是一种特殊数据类型，它相当于被引用数据的别名，不会分配新的内存空间。引用其实就是封装了指针，它比指针更容易使用，容错性也更高，在大部分场合可以替代指针。\n\n引用必须先声明后使用，一旦声明后，引用关系就不能改变。\n\n```\nint a = 3;\nint b = a;   // 定义一个 int 类型的变量 b，其初始值和变量 a 一样\nint& c = a;  // 定义(或声明)一个 int 类型引用 c，它是变量 a 的引用，其实就是变量 a 的别名\n\nb++;\ncout << a << endl;  // 3\n\nc++;\ncout << a << endl;  // 4\n\na++;\ncout << c << endl;  // 5\n\n```\n\n常引用：在定义引用时左侧加上 const 关键字修饰，表示该引用的目标是只读的（在该引用眼中），不能通过该引用对它的目标进行写操作，否则编译报错。\n\n在调用函数时，C 语言只支持传值，而 C++ 支持传值和传引用两种方式。\n\nC++ 编程建议：多使用引用，少用指针！如果函数的形参是比较大的数据（比如结构体、对象、数组等），强烈建议要用引用，效率更高；如果在函数内部不需要对引用的目标进行写操作，强烈建议使用常引用！\n\n在 C++ 中使用结构体类型、共用体类型、枚举类型时，可以不写 struct、union、enum 关键字。\n\nC++ 将标准 C 库中的头文件（比如 stdio.h、string.h、stdlib.h、time.h、math.h 等）都 copy 了一份，并换了一个新的文件名(没有后缀名 .h，加一个前缀 c），比如 cstdio、cstring、cstdlib、ctime，cmath 等。\n\n**夯实基础：**\n\n浮点数(float 和 double)在内存中是按照 IEEE754 标准规定的格式存储的，具体规则是：最高位表示符号位，0 表示正，1 表示负；接下来的若干位就是指数部分，float 类型的指数部分是 8 位，double 类型的指数部分是 11 位；剩下的位是尾数部分，float 类型的尾数部分是 23 位，double 类型的尾数部分是 52 位。\n\nfloat f = -3.125;\n\n整数部分（除 2 取余，逆序写出）：3 --> 11\n\n小数部分（乘 2 取整，正序写出，直到小数部分为零）：0.125 --> 0.25 --> 0.5 -> 1.0\n\n001\n\n十进制小数 3.125 转换为二进制小数为 11.001\n\n转换为科学计数法形式：1.1001 \\* 2^1\n\n指数部分：1 + 127 --> 128 --> 1000 0000\n\n变量 f 的存储形态：1 1000 0000 1001 0000 0000 0000 0000 000\n\nfloat f = 3.9;\n\n1.111100 1100 1100 1100 1101 0 \\* 2^1\n\n0100 0000 0111 1001 1001 1001 1001 1010 --> 40 79 99 9A\n\n1.0 \\* 2^0\n\n0011 1111 1000 0000 0000 0000 0000 0000\n\n0100 0000 0111 1001 1001 1001 1001 1010",
    "date": "2025-10-22"
  },
  {
    "id": "pa20u9okamh1pp9kd",
    "title": "STM32 GPIO 入门与常见坑",
    "category": "STM32",
    "tags": [
      "STM32",
      "GPIO",
      "HAL"
    ],
    "date": "2025-10-12",
    "content": "# STM32 GPIO 入门与常见坑\n\n**目标**：快速把 GPIO 配置起来并避免常见问题。\n\n## 关键点\n- 时钟：先使能 `__HAL_RCC_GPIOx_CLK_ENABLE()`\n- 模式：推挽/开漏 + 上拉/下拉\n- 速度：不要一上来就 Very High\n- 复用：查 `AFx` 映射表\n\n```c\nGPIO_InitTypeDef GPIO_Init = {0};\n__HAL_RCC_GPIOA_CLK_ENABLE();\nGPIO_Init.Pin = GPIO_PIN_5;\nGPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;\nGPIO_Init.Pull = GPIO_NOPULL;\nGPIO_Init.Speed = GPIO_SPEED_FREQ_LOW;\nHAL_GPIO_Init(GPIOA, &GPIO_Init);\n```\n\n> 小贴士：外设复用时一定要同时配置 `AF` 和 `Mode`。"
  },
  {
    "id": "pochyxpr1mh1pp9kd",
    "title": "C 指针速查：从地址到数组",
    "category": "C",
    "tags": [
      "C",
      "指针",
      "内存"
    ],
    "date": "2025-09-15",
    "content": "# C 指针速查\n\n- `&` 取地址，`*` 解引用  \n- 数组名在表达式中会衰减为指向首元素的指针  \n- `const` 位置不同，语义不同：`const int *p` vs `int * const p`\n\n```c\nint a = 10;\nint *p = &a;  // p 保存 a 的地址\nprintf(\"%d\\n\", *p); // 解引用得到 10\n```\n\n[CPPReference：指针](https://en.cppreference.com/w/c/language/pointer)"
  },
  {
    "id": "poxq1arz9mh1pp9kd",
    "title": "C++ 智能指针一页纸",
    "category": "C++",
    "tags": [
      "C++",
      "智能指针",
      "RAII"
    ],
    "date": "2025-08-28",
    "content": "# C++ 智能指针\n\n- `unique_ptr`：独占所有权，禁止拷贝，可移动  \n- `shared_ptr`：共享所有权，引用计数  \n- `weak_ptr`：观察者，不影响计数，解决环引用  \n\n```cpp\nauto p = std::make_unique<int>(42);\n```\n\n> 经验：优先使用 `unique_ptr`，必要时再考虑 `shared_ptr`。"
  }
]